<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Discord Archive Viewer (GAS)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root{--bg:#fbfbfb;--panel:#f3f3f4;--hover:#eeeeef;--panel-hover:#e7e7e9;--selected:#dddde0;--text:#333;--text-2:#9aa3ac}
body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text)}
.app{display:flex;height:100vh}
.sidebar{width:300px;background:var(--panel);padding:12px;box-sizing:border-box;overflow:auto}
.header{font-weight:700;color:var(--text);margin-bottom:8px}
.controls{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap}
.controls input{font-size:12px}
.tree{margin:0;padding:0;list-style:none}
.category{margin-bottom:8px;color:var(--text-2)}
.cat-title:hover{background-color: var(--panel-hover);}
.cat-title{font-weight:600;padding:6px 8px;background:var(--panel);border-radius:6px;cursor:pointer}
.cat-title .arrow{display:inline-block;font-size:12px;margin-right:6px;user-select:none}
.cat-title .arrow.opened{transform:rotate(0deg)}
.cat-title .arrow.closed{transform:rotate(-90deg)}
.channels{margin-top:6px;padding-left:10px;list-style:none}
.channel{padding:4px 6px;border-radius:6px;cursor:pointer;color:var(--text-2)}
.channel.selected{background:var(--selected);color:var(--text)}
.channel:not(.selected):hover{background:var(--panel-hover);color:var(--text-2)}
.main{flex:1;display:flex;flex-direction:column}
.topbar{height:60px;background:var(--bg);padding:12px 16px;display:flex;align-items:center;border-bottom:1px solid rgba(0,0,0,0.2)}
.room-title{font-weight:700}
.msg-groups{flex:1;overflow:auto;display:flex;flex-direction:column;gap:12px;width: 100%;}
.msg-container{display: flex; flex-direction: row;width: 100%;}
.msg-main{display:flex;flex-direction: column;align-items:flex-start;max-width:100%}
.a-side .avatar{width:36px;flex-shrink:0;background:var(--bg);border-radius:6px;display:flex;align-items:center;justify-content:center}
.a-side .avatar img{width:36px;height:36px;border-radius:6px;display:block;object-fit:cover}
.a-side .avatar img.placeholder{background:transparent;display:block}
.msg-group .msg-container{background:var(--bg);padding:10px;border-radius:8px;max-width:78%;box-shadow:0 1px 0 rgba(0,0,0,0.2);min-width:0}
.msg-container .msg-header{font-size:12px;color:var(--text-2);display:block}
.msg-main .content{font-size:14px;color:var(--text);white-space:pre-wrap;word-break:break-word}
.msg-main .content img.attachment{max-width:60%;border-radius:6px;margin-top:8px;display:block}
.footer{height:48px;padding:8px 12px;background:var(--panel);border-top:1px solid rgba(0,0,0,0.2);display:flex;align-items:center}
.muted{color:var(--text-2);font-size:13px}
.small{font-size:12px;color:var(--text-2)}
a.link{text-decoration:none}
/* group styling (更新) */
.msg-group{
  display:flex;
  flex-direction:column;
  gap:0; /* グループ内は余白なし */
  align-items:flex-start;
  background: var(--bg);
  border-radius:0; /* 丸みをなくす */
  padding:0; /* ボックスの余白をなくす */
  margin:0; /* グループ間の余白はメッセージ列側で制御する */
  width:100%;
  box-shadow:none;
  transition:none;
}
.msg-group  .msg-container{margin:0;transition:filter 120ms, transform 120ms; background:var(--bg); border-radius:0; padding:8px 10px;} /* メッセージは余白なしで配置、内部パディングだけ確保 */
.msg-group  .msg-container:hover{ background-color: var(--hover); }


/* メッセージ hover 時に表示する時刻（hh:mm） */
.msg-time{
  color:var(--text-2);
  font-size:12px;
  margin-right:8px;
  align-self:flex-start;
  opacity:0;
  transition:opacity 120ms;
  user-select:none;
}
/* Containerにホバーしたときだけ表示 */
.msg-group .msg-container:hover .msg-time{ opacity:1; }

/* 保険: avatar の左マージンを維持しつつ group はフル幅に見えるように */
.msg-group .msg-aside{ margin-right:10px; align-self:flex-start; }

/* 追加: サーバーヘッダー（アイコン + サーバー名） */
.server-header{display:flex;align-items:center;gap:8px;padding:8px 4px;margin-bottom:8px;border-radius:6px;background: var(--panel)}
.server-header img{width:40px;height:40px;border-radius:6px;object-fit:cover}
.server-header .server-name{font-weight:700;color:var(--text)}
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="header">Viewer (GAS)
      <span class="theme-toggle">■</span>
    </div>
    <div class="controls">
      <label class="small">Avatar msgpack
        <select id="avatarSelect" style="font-size:12px;width:200px">
          <option value="">-- 読み込み中... --</option>
        </select>
      </label>
      <br>
      <label class="small">Log msgpack
        <select id="logSelect" style="font-size:12px;width:200px">
          <option value="">-- 読み込み中... --</option>
        </select>
      </label>
      <br>
      <button id="loadBtn" style="padding:4px 8px;font-size:12px">読み込む</button>
    </div>
    <div id="status" class="small muted">ファイル一覧を読み込み中...</div>

    <div id="serverHeader" class="server-header" style="display:none">
      <img id="serverIcon" alt="server icon">
      <div class="server-name" id="serverName">Server</div>
    </div>

    <ul id="tree" class="tree"></ul>
  </aside>

  <main class="main">
    <div class="topbar">
      <div>
        <div id="roomTitle" class="room-title">未選択</div>
        <div id="roomSub" class="small muted">チャンネルを選択してください</div>
      </div>
    </div>
    <div id="messages" class="messages"></div>
    <div class="footer"><div class="muted">ローカル表示のみ。msgpack内のデータは埋め込みから表示します。</div></div>
  </main>
</div>

<script>
const avatarSelect = document.getElementById('avatarSelect');
const logSelect = document.getElementById('logSelect');
const loadBtn = document.getElementById('loadBtn');
const treeEl = document.getElementById('tree');
const status = document.getElementById('status');
const messagesEl = document.getElementById('messages');
const roomTitle = document.getElementById('roomTitle');
const roomSub = document.getElementById('roomSub');

const serverHeaderEl = document.getElementById('serverHeader');
const serverIconEl = document.getElementById('serverIcon');
const serverNameEl = document.getElementById('serverName');
let serverLabel = null;

const themeToggle = document.querySelector('.theme-toggle');

function applyTheme(isDark){
  document.body.classList.toggle('dark-mode', isDark);
  document.body.classList.toggle('light-mode', !isDark);

  if(isDark){
    document.documentElement.style.setProperty('--bg', '#1a1a1e');
    document.documentElement.style.setProperty('--panel', '#121214');
    document.documentElement.style.setProperty('--hover', '#242428');
    document.documentElement.style.setProperty('--panel-hover', '#1d1d1e');
    document.documentElement.style.setProperty('--selected', '#2c2c30');
    document.documentElement.style.setProperty('--text', '#ddd');
  } else {
    document.documentElement.style.setProperty('--bg', '#fbfbfb');
    document.documentElement.style.setProperty('--panel', '#f3f3f4');
    document.documentElement.style.setProperty('--hover', '#eeeeef');
    document.documentElement.style.setProperty('--panel-hover', '#e7e7e9');
    document.documentElement.style.setProperty('--selected', '#dddde0');
    document.documentElement.style.setProperty('--text', '#333');
  }
}

const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
applyTheme(prefersDark);

const saved = localStorage.getItem('theme');
if(saved){
  applyTheme(saved === 'dark');
} else {
  applyTheme(matchMedia('(prefers-color-scheme: dark)').matches);
}

themeToggle.addEventListener('click', ()=>{
  const isDark = !document.body.classList.contains('dark-mode');
  applyTheme(isDark);
  localStorage.setItem('theme', isDark ? 'dark' : 'light');
});



function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function getColorForId(id){
  if(!id) id='unknown';
  let h=0; for(let i=0;i<id.length;i++){ h=(h<<5)-h+id.charCodeAt(i); h|=0; }
  const r=(h>>16)&0xFF,g=(h>>8)&0xFF,b=h&0xFF; const clamp=v=>Math.max(60,Math.min(220,Math.abs(v)));
  return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
}

let avatarMap = {}; // userId -> { url?: string, name?: string, color?: string }

// 現在表示中のチャンネル情報（アバター後に再描画するために保持）
let currentCat = null;
let currentCh = null;
let currentChannelData = null;

function loadAvatarsFromObj(obj){
  // obj: { userId: Uint8Array | binary | [name,color,bytes], ... }
  // 既存の URL を解放してから更新（メモリリーク防止）
  for(const k in avatarMap){
    try{ if(avatarMap[k] && avatarMap[k].url) URL.revokeObjectURL(avatarMap[k].url); }catch(e){}
  }
  avatarMap = {};
  for(const k in obj){
    const v = obj[k];
    if(!v) continue;
    try{
      let name = undefined, color = undefined, imgBytes = undefined;
      // 値が配列の場合: [name, color, bytes]
      if(Array.isArray(v) && v.length>=3){
        name = v[0];
        color = v[1];
        imgBytes = v[2];
      } else if(v && typeof v === 'object' && ('0' in v) && ('2' in v)){ // msgpack decoded array-like
        name = v[0];
        color = v[1];
        imgBytes = v[2];
      } else {
        // 生のバイト列（Uint8Array / ArrayBuffer / Blob など）
        imgBytes = v;
      }

      let url = null;
      if(imgBytes){
        try{
          const blob = new Blob([imgBytes], { type: 'image/png' });
          url = URL.createObjectURL(blob);
        }catch(e){ console.warn('avatar conv err', e); }
      }
      avatarMap[String(k)] = { url, name, color };
    }catch(e){ console.warn('avatar conv err', e); }
  }
  // サーバーヘッダーを更新
  renderServerHeader();
  // アバター読み込み後、現在表示中のチャンネルがあれば再描画して反映する
  if(currentCat && currentCh && currentChannelData){
    setTimeout(()=> renderChannel(document.querySelector('.channel.selected'),currentCat, currentCh, currentChannelData), 50);
  }
}

// ページ読み込み時に自動でファイル一覧を取得
window.addEventListener('DOMContentLoaded', ()=>{
  status.textContent = 'フォルダー内のファイルを検索中...';
  
  google.script.run
    .withSuccessHandler((files)=>{
      if(!files || files.length === 0){
        status.textContent = 'フォルダー内に.msgpackファイルが見つかりません';
        avatarSelect.innerHTML = '<option value="">-- ファイルなし --</option>';
        logSelect.innerHTML = '<option value="">-- ファイルなし --</option>';
        return;
      }
      
      // selectボックスをクリア
      avatarSelect.innerHTML = '<option value="">-- 選択してください --</option>';
      logSelect.innerHTML = '<option value="">-- 選択してください --</option>';
      
      // ファイルを追加
      files.forEach(file => {
        const optAvatar = document.createElement('option');
        optAvatar.value = file.id;
        optAvatar.textContent = file.name;
        avatarSelect.appendChild(optAvatar);
        
        const optLog = document.createElement('option');
        optLog.value = file.id;
        optLog.textContent = file.name;
        logSelect.appendChild(optLog);
      });
      
      status.textContent = `${files.length}個の.msgpackファイルが見つかりました`;
    })
    .withFailureHandler((e)=>{
      status.textContent = 'エラー: ' + e;
      console.error(e);
      avatarSelect.innerHTML = '<option value="">-- エラー --</option>';
      logSelect.innerHTML = '<option value="">-- エラー --</option>';
    })
    .getMsgpackFilesInFolder();
});

// GAS連携: Google Driveファイルを読み込む
loadBtn.addEventListener('click', async ()=> {
    const avatarId = avatarSelect.value;
    const logId = logSelect.value;

    if (!avatarId || !logId) {
        status.textContent = 'アバターとログの両方を選択してください';
        return;
    }

    status.textContent = '読み込み中...';

    try {
        google.script.run
            .withSuccessHandler((result) => {
                if (result.avatar && result.log) {
                    // Check if the msgpack data is too large
                    const avatarChunks = splitMsgpack(result.avatar.data, 100000); // 100KB chunks
                    const logChunks = splitMsgpack(result.log.data, 100000); // 100KB chunks

                    // Process each chunk (you may need to implement further handling)
                    avatarChunks.forEach(chunk => {
                        // Handle each avatar chunk
                    });
                    logChunks.forEach(chunk => {
                        // Handle each log chunk
                    });

                    status.textContent = `読み込み完了: ${result.avatar.name}, ${result.log.name}`;
                } else {
                    status.textContent = 'ファイルの読み込みに失敗しました';
                }
            })
            .withFailureHandler((e) => {
                status.textContent = 'エラー: ' + e;
                console.error(e);
            })
            .loadFilesFromDrive(avatarId, logId);
    } catch (e) {
        status.textContent = 'エラー: ' + e;
        console.error(e);
    }
});

function renderServerHeader(){
  // serverLabel は buildTreeFromServerData で設定されることがある
  const special = avatarMap["__server_icon__"];
  const name = (special && special.name) ? special.name : (serverLabel || null);
  const url = (special && special.url) ? special.url : null;
  if(!name && !url){
    serverHeaderEl.style.display = 'none';
    return;
  }
  serverHeaderEl.style.display = 'flex';
  serverNameEl.textContent = name || 'Server';
  if(url){
    serverIconEl.src = url;
    serverIconEl.onclick = ()=> window.open(url, '_blank');
  } else {
    // 簡易 SVG プレースホルダ
    const color = (special && special.color) ? special.color : getColorForId(name||'server');
    const label = (name||'S').slice(0,2);
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40'><rect width='100%' height='100%' rx='6' fill='${color}'/><text x='50%' y='50%' font-size='14' fill='#fff' text-anchor='middle' dominant-baseline='middle'>${escapeHtml(label)}</text></svg>`;
    serverIconEl.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
    serverIconEl.onclick = null;
  }
}

function buildTreeFromServerData(serverName, data){
  serverLabel = serverName || null;
  renderServerHeader();
  treeEl.innerHTML = '';
  for(const cat of Object.keys(data)){
    const catLi = document.createElement('li'); catLi.className='category';
    const title = document.createElement('div'); title.className='cat-title';
    const arrow = document.createElement('span'); arrow.className='arrow closed';arrow.textContent='⌵';
    const catName = document.createElement('span'); catName.className='catName';catName.textContent= cat+' ';
    title.appendChild(catName); title.appendChild(arrow);
    catLi.appendChild(title);
    const chUl = document.createElement('ul'); chUl.className='channels';
    chUl.style.display='none';
    const channels = data[cat] || {};
    for(const ch of Object.keys(channels)){
      const chLi = document.createElement('li');
      const a = document.createElement('div'); a.className='channel'; a.textContent = '# '+ch;
      a.addEventListener('click', ()=> renderChannel(a,cat, ch, channels[ch]));
      chLi.appendChild(a); chUl.appendChild(chLi);
    }
    catLi.appendChild(chUl); treeEl.appendChild(catLi);
    title.addEventListener('click', ()=> {
      const opened = chUl.style.display !=='none';
      chUl.style.display = opened ? 'none':'block';
      arrow.classList.toggle('closed', opened);
      arrow.classList.toggle('opened', !opened);
    });
  }
  // auto-select first
  const first = treeEl.querySelector('.channel');
  if(first) setTimeout(()=> first.click(), 50);
}

function asBlobURLFromContent(info){
  // info may be: Uint8Array / {filename,data,url,content_type} / ArrayBuffer
  try{
    if(!info) return null;
    if(info.data || info.content_type){
      const data = info.data || info;
      const blob = new Blob([data], { type: info.content_type || 'application/octet-stream' });
      return URL.createObjectURL(blob);
    }
    // raw Uint8Array
    const blob = new Blob([info], { type: 'application/octet-stream' });
    return URL.createObjectURL(blob);
  }catch(e){ console.warn('blob conv err', e); return null; }
}

function renderChannel(ev,cat, ch, channelData){
  // 現在表示中のチャンネルを記録
  currentCat = cat;
  currentCh = ch;
  currentChannelData = channelData;
  document.querySelectorAll('.channel').forEach(el =>{el.classList.remove('selected');});
  ev.classList.add('selected');
  roomTitle.textContent = ch; roomSub.textContent = cat;
  messagesEl.innerHTML = '';
  const entries = (channelData && channelData.messages) ? channelData.messages : [];
  if(!entries || entries.length===0){
    if(channelData && channelData.threads && Object.keys(channelData.threads).length){
      messagesEl.innerHTML = '<div class="muted">メッセージはありません（スレッドあり）</div>';
      for(const tname of Object.keys(channelData.threads)){
        const tdiv = document.createElement('div'); tdiv.className='muted'; tdiv.textContent = `Thread: ${tname} (${(channelData.threads[tname]||[]).length})`;
        messagesEl.appendChild(tdiv);
      }
      return;
    }
    messagesEl.innerHTML = '<div class="muted">メッセージはありません</div>'; return;
  }

  // 1) フラットなメッセージ配列を生成（元の順序を維持）
  const flat = [];
  for(const item of entries){
    for(const mid in item){
      flat.push({ mid, payload: item[mid] });
    }
  }

  // 2) グルーピング（同一 author && 前メッセージから <= 7分(420秒)）
  const groups = [];
  for(const m of flat){
    const p = m.payload || {};
    const author = p.author_id ? String(p.author_id) : null;
    const ts = Number(p.ts) || 0;
    const last = groups.length ? groups[groups.length-1] : null;
    if(last && author && last.author === author && (ts - last.lastTs) <= 420){
      last.messages.push({ mid: m.mid, payload: p });
      last.lastTs = ts;
    } else {
      groups.push({ author, messages: [{ mid: m.mid, payload: p }], lastTs: ts });
    }
  }

  // 3) グループごとに DOM を生成
  for(const g of groups){
    const msgCntGroupDiv = document.createElement('div'); msgCntGroupDiv.className = 'msg-group';



    // 各メッセージを row (バブルのみ) として追加
    for(let i=0;i<g.messages.length;i++){
      const msgContainerDiv = document.createElement('div'); msgContainerDiv.className='msg-container';
      const msgAsideDiv = document.createElement('div'); msgAsideDiv.className='a-side'; 
      const m = g.messages[i];
      const payload = m.payload || {};
      const typ = payload.type || 'text';
      const ts = payload.ts || '';

      const msgMainDiv = document.createElement('div'); msgMainDiv.className='msg-main';

      // メッセージ毎に表示名は先頭バブルのみメタで表示
      if(i===0){    
        // アバター（グループ単位で一度だけ）
        const avatarDiv = document.createElement('div'); avatarDiv.className='avatar';
        const idStr = g.author;
        const avEntry = idStr ? avatarMap[idStr] : null;
        const avUrl = avEntry ? avEntry.url : null;
        if(avUrl){
          const av = document.createElement('img'); av.src = avUrl; av.alt='avatar'; avatarDiv.appendChild(av);
        } else {
          const label = idStr ? String(avEntry && avEntry.name ? avEntry.name.slice(0,2) : (idStr.slice(-4))) : '?';
          const color = (avEntry && avEntry.color) ? avEntry.color : getColorForId(idStr||'unknown');
          const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='36' height='36'><rect width='100%' height='100%' rx='6' fill='${color}'/><text x='50%' y='50%' font-size='12' fill='#fff' text-anchor='middle' dominant-baseline='middle'>${escapeHtml(label)}</text></svg>`;
          const src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
          const av = document.createElement('img'); av.src = src; av.alt='avatar'; av.className='placeholder'; avatarDiv.appendChild(av);
        }
        msgAsideDiv.appendChild(avatarDiv);
        const msgHeaderDiv = document.createElement('div'); msgHeaderDiv.className='msg-header';
        const nameSpan = document.createElement('span');
        const displayName = (avEntry && avEntry.name) ? String(avEntry.name) : (g.author ? ('ID:'+m.mid) : '');
        const nameColor = (avEntry && avEntry.color) ? avEntry.color : getColorForId(g.author||String(m.mid));
        nameSpan.textContent = displayName;
        nameSpan.style.color = nameColor;
        nameSpan.title = g.author ? ('ID:'+g.author) : '';
        nameSpan.style.fontSize = '15px';
        const timeStampSpan = document.createElement('span'); timeStampSpan.className = 'timeStamp';
        if(ts){
          const d = new Date(ts*1000);
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth()+1).padStart(2,'0');
          const dd = String(d.getDate()).padStart(2,'0');
          const hh = String(d.getHours()).padStart(2,'0');
          const min = String(d.getMinutes()).padStart(2,'0');
          formattedDate = ` • ${yyyy}/${mm}/${dd} ${hh}:${min}`;
          timeStampSpan.textContent = formattedDate;
          timeStampSpan.title = formattedDate;
        }
        msgHeaderDiv.appendChild(nameSpan);
        msgHeaderDiv.appendChild(timeStampSpan);
        msgMainDiv.appendChild(msgHeaderDiv);
      }else{
        // 時刻表示要素（hh:mm）をバブル内に追加、ホバーで表示
        const timeSpan = document.createElement('span'); timeSpan.className = 'msg-time';
        if(ts){
          const d = new Date(ts*1000);
          const hh = String(d.getHours()).padStart(2,'0');
          const min = String(d.getMinutes()).padStart(2,'0');
          timeSpan.textContent = hh + ':' + min;
          // フル日時をツールチップに保持
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth()+1).padStart(2,'0');
          const dd = String(d.getDate()).padStart(2,'0');
          timeSpan.title = yyyy + '/' + mm + '/' + dd + ' ' + hh + ':' + min;
        }
        // timeSpan はバブル内の最初に配置して左側に見えるようにする
        msgAsideDiv.appendChild(timeSpan);
      }

      const content = document.createElement('div'); content.className='content';
      if(typ==='text' || typ==='emoji'){
        content.textContent = payload.content || '';
      } else if(typ==='img'){
        const info = payload.content || {};
        let url = null;
        if(info && (info.data || info.length)) url = asBlobURLFromContent(info);
        else if(info && info.url) url = info.url;
        if(url){
          const a = document.createElement('a'); a.href = url; a.target='_blank'; a.rel='noopener noreferrer';
          const img = document.createElement('img'); img.className='attachment'; img.src = url; a.appendChild(img); content.appendChild(a);
        } else {
          content.innerHTML = '<span class="muted">画像データがありません</span>';
        }
      } else {
        content.textContent = payload.content || '';
      }

      msgMainDiv.appendChild(content);
      msgContainerDiv.appendChild(msgAsideDiv);
      msgContainerDiv.appendChild(msgMainDiv);
      msgCntGroupDiv.appendChild(msgContainerDiv);
    }

    messagesEl.appendChild(msgCntGroupDiv);
  }

  messagesEl.scrollTop = messagesEl.scrollHeight;
}
</script>
</body>
</html>
